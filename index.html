<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="scripts/glMatrix-0.9.5.min.js"></script>

		<script id="shader-cube-fs" type="x-shader/x-fragment">
			precision mediump float;
			
			varying vec2 vTextureCoord;
			
			uniform sampler2D uSampler;
			
			varying vec3 vLightWeighting;
			
			void main(void)
			{
				//gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				
				vec4 colour = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
				gl_FragColor = vec4(colour.rgb * vLightWeighting, colour.a);
			}
		
		</script>
		
		<script id="shader-cube-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec2 aTextureCoord;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			
			varying vec2 vTextureCoord;
			
			attribute vec3 aVertexNormal;
			uniform mat3 uNMatrix;
			
			uniform vec3 uAmbientColour;
			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColour;
			
			varying vec3 vLightWeighting;
			
			void main(void)
			{
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vTextureCoord = aTextureCoord;
				
				vec3 transformedNormal = uNMatrix * aVertexNormal;
				float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
				vLightWeighting = uAmbientColour + uDirectionalColour * directionalLightWeighting;
			}
		</script>
		
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec4 vColour;
			
			varying vec3 vLightWeighting;
			
			void main(void) 
			{
				gl_FragColor = vec4(vColour.rgb * vLightWeighting, vColour.a);
			}
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec4 aVertexColour;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec4 vColour;
			
			uniform vec3 uAmbientColour;
			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColour;
			
			varying vec3 vLightWeighting;
			
			void main(void) 
			{
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColour = aVertexColour;
				
				vec3 transformedNormal = uNMatrix * aVertexNormal;
				float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
				vLightWeighting = uAmbientColour + uDirectionalColour * directionalLightWeighting;
			}
			
		</script>
	
		<script type="text/javascript">
		
			var m_w = 123456789;
			var m_z = 987654321;
			var mask = 0xffffffff;

			function seed(i) 
			{
				m_w = i;
				m_z = 987654321;
				mask = 0xffffffff;
			}

			function random()
			{
				m_z = (36969 * (m_z & 65535) + (m_z >> 16)) & mask;
				m_w = (18000 * (m_w & 65535) + (m_w >> 16)) & mask;
				var result = ((m_z << 16) + m_w) & mask;
				result /= 4294967296;
				return result + 0.5;
			}
			
			//var width = 6;
			//var height = 6;
			
			var width = 12;
			var height = 12;
			
			var height_map = new Array(width * height);
			
			var temp_x = new Array(width * height);
			var temp_y = new Array(width * height);
			
			var position_x = 0;
			var position_y = 0;
			
			function start()
			{
				for(var i = 0; i < width * height; ++i)
				{
					height_map[i] = 0;
				}
				
				position_x = 0;
				seed(position_x);
				
				for(var x = 0; x < width; ++x)
				{
					seed(x);
					init_vertical(x);
				}
			}
						
			
			function init_vertical(x_offset)
			{
				var y;
				var x = x_offset;
				
				for(y = 0; y < height; ++y)
				{
					height_map[x] = random();
					x += width;
				}
			}
		
			function init_horz(y_offset)
			{
				var y = y_offset * width;
				var x;
				
				for(x = 0; x < width; ++x)
				{
					height_map[y + x] = random();
				}
			}
			
			function ror()
			{
				var yoffset = 0;
				for(var y = 0; y < height; ++y)
				{
					for(var x = width - 1; x >= 0; x--)
					{
						var destination = yoffset + x;
						var source = destination - 1;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rol()
			{
				var yoffset = 0;
				for(var y = 0; y < height; ++y)
				{
					for(var x = 0; x < width - 1; ++x)
					{
						var destination = yoffset + x;
						var source = destination + 1;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rou()
			{
				var yoffset = 0;
				for(var y = 0; y < height - 1; ++y)
				{
					for(var x = 0; x < width; ++x)
					{
						var destination = yoffset + x;
						var source = yoffset + width + x;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rod()
			{
				var yoffset = (height - 1) * width;
				for(var y = height - 1; y >= 0; --y)
				{
					for(var x = 0; x < width; ++x)
					{
						var destination = yoffset + x;
						var source = (yoffset - width) + x;
						height_map[destination] = height_map[source];
					}
					yoffset -= width;
				}
			}

			function hash(a, b)
			{
				return (a << 1) ^ b;
			}
					
		</script>
		
		<script type="text/javascript">
		
			function catmull(t0, t1, t2, t3, position)
			{
				var time2 = position * position;
				var time3 = position * position * position;

				var temp = (2.0 * t1) + (-t0 + t2) * position;
				temp += (2.0 * t0 - 5.0 * t1 + 4.0 * t2 - t3) * time2;
				temp += (-t0 + 3.0 * t1 - 3.0 * t2 + t3) * time3;
				temp *= 0.5;

				return temp;
			}
			
			/*
			var x_terms = [  0.0, 20.0, 40.0, 40.0, 40.0, 20.0,  0.0,  0.0 ];
			var y_terms = [  0.0,  0.0,  0.0, 20.0, 40.0, 40.0, 40.0, 20.0 ];
			var z_terms = [  2.0,  2.0,  2.0,  2.0,  2.0,  2.0,  2.0,  2.0 ];
			
			var looking_x_terms = [ 20.0, 40.0, 40.0, 40.0, 20.0,  0.0,  0.0,  0.0 ];
			var looking_y_terms = [  0.0,  0.0, 20.0, 40.0, 40.0, 40.0, 20.0,  0.0 ];
			var looking_z_terms = [  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0 ];
			*/
			var x_terms = [  0.0, 20.0, 40.0, 40.0, 40.0 ];
			var y_terms = [  0.0,  0.0,  0.0, 20.0, 40.0 ];
			var z_terms = [  2.0,  2.0,  2.0,  2.0,  2.0 ];
			
			var looking_x_terms = [ 20.0, 40.0, 40.0, 40.0 ];
			var looking_y_terms = [  0.0,  0.0, 20.0, 40.0 ];
			var looking_z_terms = [  0.0,  0.0,  0.0,  0.0 ];
			
			//[  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0,  0.0 ];//24.5,  24.5,  24.5,  24.5,  24.5,  24.5,  24.5,  24.5 ];
	
			var cube_x_terms = [  5.0, 15.0, 45.0, 35.0, 45.0, 20.0,  5.0,  0.0 ];
			var cube_z_terms = [  0.0,  0.0,  0.0, 0.0, 0.0, 0.0, 0.0, 0.0 ];//20.0, 40.0, 40.0, 40.0, 20.0 ];
			var cube_y_terms = [  -12.0,  -12.0,  -12.0,  -12.0,  -12.0,  -12.0,  -12.0,  -12.0 ];
			
			//var cube_x_terms = [ 20.0, 40.0, 40.0, 40.0, 20.0,  0.0,  0.0,  0.0 ];
			//var cube_y_terms = [  0.0,  0.0, 20.0, 40.0, 40.0, 40.0, 20.0,  0.0 ];
			//var cube_z_terms = [  2.0,  2.0,  2.0,  2.0,  2.0,  2.0,  2.0,  2.0 ];
			// start a few ticks after landscape moves
			// move slightly faster than landscape increment
			
			var termIndex = 0;
			var termPosition = 0.0;
			var termIncrement = 0.005;
			//var termIncrement = 0.001;

			var termCubeIndex = 0;
			var termCubePosition = 0.0;
			var termCubeIncrement = 0.005;
			//var termCubeIncrement = 0.005;
			
			var xt = [ 0.0, 0.0, 0.0, 0.0 ];
			var yt = [ 0.0, 0.0, 0.0, 0.0 ];
			var zt = [ 0.0, 0.0, 0.0, 0.0 ];
			
			var cubext = [ 0.0, 0.0, 0.0, 0.0 ];
			var cubeyt = [ 0.0, 0.0, 0.0, 0.0 ];
			var cubezt = [ 0.0, 0.0, 0.0, 0.0 ];
			
			var lookingxt = [ 0.0, 0.0, 0.0, 0.0 ];
			var lookingyt = [ 0.0, 0.0, 0.0, 0.0 ];
			var lookingzt = [ 0.0, 0.0, 0.0, 0.0 ];
			
			var lastX_walk = 0.0;
			var lastY_walk = 0.0;

			var lastX_walk_increment = 40.0;
			var lastY_walk_increment = 40.0;
			
			function generatePaths()
			{
				var terms = 8;
				var i;
				
				for(i = 0; i < terms; ++i)
				{
					var x = Math.random() * lastX_walk_increment;
					var y = Math.random() * lastY_walk_increment;
					
					x_terms[i] = lastX_walk + x;
					y_terms[i] = lastY_walk + y;
					
					lastX_walk += x;
					lastY_walk += y;
				}
				
				for(i = 0; i < terms - 1; ++i)
				{
					looking_x_terms[i] = x_terms[i + 1];
					looking_y_terms[i] = y_terms[i + 1];
					
					cube_x_terms[i] = x_terms[i + 1];
				}
			}
			
			function getNextPath()
			{
				var terms = 8;
				var i;
				
				for(i = 0; i < terms - 1; ++i)
				{
					x_terms[i] = x_terms[i + 1];
					y_terms[i] = y_terms[i + 1];
					
					looking_x_terms[i] = x_terms[i + 1];
					looking_y_terms[i] = y_terms[i + 1];
					
					cube_x_terms[i] = x_terms[i + 1];
				}

				var x = Math.random() * lastX_walk_increment;
				var y = Math.random() * lastY_walk_increment;
				
				var tx = lastX_walk + x;
				var ty = lastY_walk + y;
				
				x_terms[terms - 1] = tx;
				y_terms[terms - 1] = ty;
				
				looking_x_terms[terms - 1] = tx;
				looking_y_terms[terms - 1] = ty;
				
				cube_x_terms = tx;
				
				lastX_walk += x;
				lastY_walk += y;
			}
			
			function incTerm(index, data)
			{
				var i = index + 1;
				if(i >= data.length) i = 0;
				
				return i;
			}
							
			function initTerms(data)
			{			
				var result = [ data[0], data[1], data[2], data[3] ];
				
				return result;
			}
			
			function shuffleTerms(data)
			{
				var result = [ data[1], data[2], data[3], 0.0 ];
				
				return result;
			}
			
			function initAllTerms()
			{
				//xt = initTerms(x_terms);
				//yt = initTerms(y_terms);
				//zt = initTerms(z_terms);					
				
				//lookingxt = initTerms(looking_x_terms);
				//lookingyt = initTerms(looking_y_terms);
				//lookingzt = initTerms(looking_z_terms);
				
				termIndex = 3;
				
				cubext = initTerms(cube_x_terms);
				cubeyt = initTerms(cube_y_terms);
				cubezt = initTerms(cube_z_terms);
				
				termCubeIndex = 3;
			}
			
			function computeRotationMatrix(target_x, target_y, target_z, 
										   ref_x, ref_y, ref_z, 
										   position_x, position_y, position_z)
			{
				var v1x = position_x - target_x;
				var v1y = position_y - target_y;
				var v1z = position_z - target_z;
				
				var length = Math.sqrt(v1x * v1x + v1y * v1y + v1z * v1z);
				var t = 1.0 / (length + 0.001);
				v1x *= t; v1y *= t; v1z *= t;
				
				var angle = ref_x * v1x + ref_y * v1y + ref_z * v1z;
			
				var axis_x = v1y * ref_z - v1z * ref_y;
				var axis_y = v1z * ref_x - v1x * ref_z;
				var axis_z = v1x * ref_y - v1y * ref_x;				
				
				var s = Math.sqrt((1.0 + angle) * 2.0);
				
				axis_x = axis_x / s;
				axis_y = axis_y / s;
				axis_z = axis_z / s;
				
				angle = s / 2.0;
								
				var m = mat4.create();
				
				var xx = axis_x * axis_x;
				var yy = axis_y * axis_y;
				var zz = axis_z * axis_z;

				s = 2.0 / (xx + yy + zz + (angle * angle));
				
				m[0] = 1.0 - s * (yy + zz); m[1] = s * (axis_x * axis_y - angle * axis_z); m[2] = s * (axis_x * axis_z + angle * axis_y); m[3] = 0.0;				
				m[4] = s * (axis_x * axis_y + angle * axis_z); m[5] = 1.0 - s * (xx + zz); m[6] = s * (axis_y * axis_z - angle * axis_x); m[7] = 0.0;				
				m[8] = s * (axis_x * axis_z - angle * axis_y); m[9] = s * (axis_y * axis_z + angle * axis_x); m[10] = 1.0 - s * (xx + yy); m[11] = 0.0;				
				m[12] = 0.0; m[13] = 0.0; m[14] = 0.0; m[15] = 1.0;
				
				return m;
			}
			
			function getPosition()
			{			
				termPosition += termIncrement;
				if(termPosition > 1.0)
				{
					// initial seed
					/*
					var x_terms = [  0.0, 20.0, 40.0, 40.0, 40.0 ];
					var y_terms = [  0.0,  0.0,  0.0, 20.0, 40.0 ];
					var z_terms = [  2.0,  2.0,  2.0,  2.0,  2.0 ];
					
					var looking_x_terms = [ 20.0, 40.0, 40.0, 40.0 ];
					var looking_y_terms = [  0.0,  0.0, 20.0, 40.0 ];
					var looking_z_terms = [  0.0,  0.0,  0.0,  0.0 ];
					*/
					// ***
					
					var next_x = x_terms[4];
					var next_y = y_terms[4];
					var next_z = z_terms[4];
					
					next_x += (Math.random() * 40.0) - 20.0;
					next_y += 20.0;
					next_z = 2.0;
					
					x_terms = [ x_terms[1], x_terms[2], x_terms[3], x_terms[4], next_x ];//shuffleTerms(x_terms); // check this 
					y_terms = [ y_terms[1], y_terms[2], y_terms[3], y_terms[4], next_y ];
					z_terms = [ z_terms[1], z_terms[2], z_terms[3], z_terms[4], next_z ];
					//function can handle 5 terms
					//y_terms = shuffleTerms(y_terms);
					//z_terms = shuffleTerms(z_terms);
					
					//x_terms[4] = next_x;
					//y_terms[4] = next_y;
					//z_terms[4] = next_z;
					
					//xt = x_terms; // copy the 4 terms only over
					//yt = y_terms;
					//zt = z_terms;
					
					looking_x_terms = [ looking_x_terms[1], looking_x_terms[2], looking_x_terms[3], next_x ];//shuffleTerms(looking_x_terms);
					looking_y_terms = [ looking_y_terms[1], looking_y_terms[2], looking_y_terms[3], next_y ];
					looking_z_terms = [ looking_z_terms[1], looking_z_terms[2], looking_z_terms[3], next_z ];
					//looking_y_terms = shuffleTerms(looking_y_terms);
					//looking_z_terms = shuffleTerms(looking_z_terms);
					
					//looking_x_terms[3] = next_x;
					//looking_y_terms[3] = next_y;
					//looking_z_terms[3] = next_z;
					
					//lookingxt = looking_x_terms;
					//lookingyt = looking_y_terms;
					//lookingzt = looking_z_terms;
					
				//Math.random()
					// ****
					// ****
					// generate next term, go left, or right, or straight ahead
					// check last term for seed position
					termPosition = 0.0;
					termIndex = incTerm(termIndex, x_terms);
					/*
					xt = shuffleTerms(xt);
					xt[3] = x_terms[termIndex];
					
					yt = shuffleTerms(yt);
					yt[3] = y_terms[termIndex];
					
					zt = shuffleTerms(zt);
					zt[3] = z_terms[termIndex];
					
					lookingxt = shuffleTerms(lookingxt);
					lookingxt[3] = looking_x_terms[termIndex];
					
					lookingyt = shuffleTerms(lookingyt);
					lookingyt[3] = looking_y_terms[termIndex];
					
					lookingzt = shuffleTerms(lookingzt);
					lookingzt[3] = looking_z_terms[termIndex];
					*/
				}
				
				var x = catmull(x_terms[0], x_terms[1], x_terms[2], x_terms[3], termPosition);
				var y = catmull(y_terms[0], y_terms[1], y_terms[2], y_terms[3], termPosition);
				var z = catmull(z_terms[0], z_terms[1], z_terms[2], z_terms[3], termPosition);
				
				var lx = catmull(looking_x_terms[0], looking_x_terms[1], looking_x_terms[2], looking_z_terms[3], termPosition);
				var ly = catmull(looking_y_terms[0], looking_y_terms[1], looking_y_terms[2], looking_z_terms[3], termPosition);
				var lz = catmull(looking_z_terms[0], looking_z_terms[1], looking_z_terms[2], looking_z_terms[3], termPosition);
	
				var result = [ x, y, z, lx, ly, lz ];
				
				return result;
			}
		
			function getCubePosition()
			{							
				termCubePosition += termCubeIncrement;
				if(termCubePosition > 1.0)
				{
					termCubePosition = 0.0;
					termCubeIndex = incTerm(termCubeIndex, cube_x_terms);
					
					cubext = shuffleTerms(cubext);
					cubext[3] = cube_x_terms[termCubeIndex];
					
					cubeyt = shuffleTerms(cubeyt);
					cubeyt[3] = cube_y_terms[termCubeIndex];
					
					cubezt = shuffleTerms(cubezt);
					cubezt[3] = cube_z_terms[termCubeIndex];					
				}
				
				var x = catmull(cubext[0], cubext[1], cubext[2], cubext[3], termCubePosition);
				var y = catmull(cubeyt[0], cubeyt[1], cubeyt[2], cubeyt[3], termCubePosition);
				var z = catmull(cubezt[0], cubezt[1], cubezt[2], cubezt[3], termCubePosition);

				var result = [ x, y, z ];
				
				return result;
			}
		</script>
		
		<script type="text/javascript">

			var gl;
			
			function initGL(canvas) 
			{
				try 
				{
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
				} 
				catch (e)
				{
				}

				if (!gl) alert("Could not initialise WebGL, sorry :-(");
			}

			function getShader(gl, id) 
			{
				var shaderScript = document.getElementById(id);
				if (!shaderScript) return null;

				var str = "";
				var k = shaderScript.firstChild;
				while (k) 
				{
					if (k.nodeType == 3) 
					{
						str += k.textContent;
					}
					k = k.nextSibling;
				}

				var shader;
				if (shaderScript.type == "x-shader/x-fragment") 
				{
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} 
				else if (shaderScript.type == "x-shader/x-vertex") 
				{
					shader = gl.createShader(gl.VERTEX_SHADER);
				} 
				else return null;

				gl.shaderSource(shader, str);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
				{
					alert(gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			var shaderProgram;
			var shaderCubeProgram;
			
			function initShaders()
			{
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) 
				{
					alert("Could not initialise shaders");
				}

				gl.useProgram(shaderProgram);

				shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

				shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
				gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				
				shaderProgram.vertexColourAttribute = gl.getAttribLocation(shaderProgram, "aVertexColour");
				gl.enableVertexAttribArray(shaderProgram.vertexColourAttribute);

				shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
				shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");				
				shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
			
				shaderProgram.ambientColourUniform = gl.getUniformLocation(shaderProgram, "uAmbientColour");
				shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
				shaderProgram.directionalColourUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColour");
			}
			
			function initCubeShader()
			{
				var fragmentShader = getShader(gl, "shader-cube-fs");
				var vertexShader = getShader(gl, "shader-cube-vs");

				shaderCubeProgram = gl.createProgram();
				gl.attachShader(shaderCubeProgram, vertexShader);
				gl.attachShader(shaderCubeProgram, fragmentShader);
				gl.linkProgram(shaderCubeProgram);

				if (!gl.getProgramParameter(shaderCubeProgram, gl.LINK_STATUS)) 
				{
					alert("Could not initialise shaders");
				}

				gl.useProgram(shaderCubeProgram);

				shaderCubeProgram.vertexPositionAttribute = gl.getAttribLocation(shaderCubeProgram, "aVertexPosition");
				gl.enableVertexAttribArray(shaderCubeProgram.vertexPositionAttribute);
			
				shaderCubeProgram.textureCoordAttribute = gl.getAttribLocation(shaderCubeProgram, "aTextureCoord");
				gl.enableVertexAttribArray(shaderCubeProgram.textureCoordAttribute);
		
				shaderCubeProgram.vertexNormalAttribute = gl.getAttribLocation(shaderCubeProgram, "aVertexNormal");
				gl.enableVertexAttribArray(shaderCubeProgram.vertexNormalAttribute);
				
				shaderCubeProgram.pMatrixUniform = gl.getUniformLocation(shaderCubeProgram, "uPMatrix");
				shaderCubeProgram.mvMatrixUniform = gl.getUniformLocation(shaderCubeProgram, "uMVMatrix");
				shaderCubeProgram.nMatrixUniform = gl.getUniformLocation(shaderCubeProgram, "uNMatrix");
				
				shaderCubeProgram.samplerUniform = gl.getUniformLocation(shaderCubeProgram, "uSampler");
				
				shaderCubeProgram.ambientColourUniform = gl.getUniformLocation(shaderCubeProgram, "uAmbientColour");
				shaderCubeProgram.lightingDirectionUniform = gl.getUniformLocation(shaderCubeProgram, "uLightingDirection");
				shaderCubeProgram.directionalColourUniform = gl.getUniformLocation(shaderCubeProgram, "uDirectionalColour");
			}
			
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();

			function setMatrixUniforms() 
			{
				gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
				
				var normalMatrix = mat3.create();
				mat4.toInverseMat3(mvMatrix, normalMatrix);
				mat3.transpose(normalMatrix);
				gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
			}

			var mvCubeMatrix = mat4.create();
			var pCubeMatrix = mat4.create();

			function setMatrixCubeUniforms() 
			{
				gl.uniformMatrix4fv(shaderCubeProgram.pMatrixUniform, false, pCubeMatrix);
				gl.uniformMatrix4fv(shaderCubeProgram.mvMatrixUniform, false, mvCubeMatrix);
				
				var normalMatrix = mat3.create();
				mat4.toInverseMat3(mvCubeMatrix, normalMatrix);
				mat3.transpose(normalMatrix);
				gl.uniformMatrix3fv(shaderCubeProgram.nMatrixUniform, false, normalMatrix);
			}

			
			var triangleVertexPositionBuffer;
			var triangleVertexNormalBuffer;
			var triangleVertexColourBuffer;
			
			var cubeVertexBuffer;
			var cubeVertexIndexBuffer;
			var cubeUVVertexBuffer;
			var cubeVertexNormalBuffer;
			
			var x_scale = 5.0;
			var y_scale = 5.0;
			var z_scale = 1.0;
				
			function initVertices()
			{
				var total_points = (width - 1) * (height - 1) * 6;
			
				var vertices = new Array(total_points * 3);				
				
				var y_value = -1.0;
				
				var y_increment = 2.0 / height;
				var x_increment = 2.0 / width;
								
				var index = 0;
				
				for(y = 0; y < height - 1; ++y)
				{
					var x_value = -1.0;
					
					for(x = 0; x < width - 1; ++x)
					{
						var top_left = (y * width) + x;
						var bottom_left = ((y + 1) * width) + x;
						
						var top_right = top_left + 1;
						var bottom_right = bottom_left + 1;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_left] * z_scale;

						
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_right] * z_scale;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_left] * z_scale;
												
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_right] * z_scale;
						
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_right] * z_scale;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_left] * z_scale;
						
						x_value += x_increment;
					}
					
					y_value += y_increment;
				}
				
				return vertices;
			}
			
			function initNormals(vertices)
			{
				var total_points = (width - 1) * (height - 1) * 6;
			
				var normals = new Array(total_points * 3);				
												
				var index;
				var output = 0;
				
				for(index = 0; index < vertices.length; index += 9)
				{
					var x1 = vertices[index];
					var y1 = vertices[index + 1];
					var z1 = vertices[index + 2];
					
					var x2 = vertices[index + 3];
					var y2 = vertices[index + 4];
					var z2 = vertices[index + 5];
					
					var x3 = vertices[index + 6];
					var y3 = vertices[index + 7];
					var z3 = vertices[index + 8];
					
					var v1x = x1 - x2;
					var v1y = y1 - y2;
					var v1z = z1 - z2;
					
					var v2x = x2 - x3;
					var v2y = y2 - y3;
					var v2z = z2 - z3;
					
					var x = v2y * v1z - v2z * v1y;
					var y = v2z * v1x - v2x * v1z;
					var z = v2x * v1y - v2y * v1x;
					
					var length = 1.0 / (Math.sqrt(x * x + y * y + z * z) + 0.001);
					
					var temp_x = x * length;
					var temp_y = y * length;
					var temp_z = z * length;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
				}
				
				return normals;
			}
			
			function initVerticesColour()
			{
				var total_points = (width - 1) * (height - 1) * 6;
				
				var colours = new Array(total_points * 4); // varies depending on height
				
				var global_width = 100.0;
				var global_height = 100.0;
				 
				var g = ((position_x / (global_width + width)) / 2.0) + 0.5;
				var f = ((position_y / (global_height + height)) / 2.0) + 0.5;
				
				var colour_increment = (1.0 / global_height) / 2.0;
				var colour_increment_x = (1.0 / global_width) / 2.0;
				
				var red = 0.0;
				var green = 0.0;
				var blue = 1.0;
				var alpha = 1.0;
				
				var colour_index = 0;
				
				for(y = 0; y < height - 1; ++y)
				{			
					for(x = 0; x < width - 1; ++x)
					{					
						// top left
						colours[colour_index++] = f + (y * colour_increment);//red;
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// top right
						colours[colour_index++] = f + (y * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom left
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// ***
						
						// top right
						colours[colour_index++] = f + (y * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom right
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom left
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;						
					}
				}
				
				return colours;
			}
			
			function initCube()
			{
				//cubeVertexBuffer = gl.createBuffer();
				//gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
				var result = [
				  // Front face
				  -1.0, -1.0,  1.0,
				   1.0, -1.0,  1.0,
				   1.0,  1.0,  1.0,
				  -1.0,  1.0,  1.0,

				  // Back face
				  -1.0, -1.0, -1.0,
				  -1.0,  1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0, -1.0, -1.0,

				  // Top face
				  -1.0,  1.0, -1.0,
				  -1.0,  1.0,  1.0,
				   1.0,  1.0,  1.0,
				   1.0,  1.0, -1.0,

				  // Bottom face
				  -1.0, -1.0, -1.0,
				   1.0, -1.0, -1.0,
				   1.0, -1.0,  1.0,
				  -1.0, -1.0,  1.0,

				  // Right face
				   1.0, -1.0, -1.0,
				   1.0,  1.0, -1.0,
				   1.0,  1.0,  1.0,
				   1.0, -1.0,  1.0,

				  // Left face
				  -1.0, -1.0, -1.0,
				  -1.0, -1.0,  1.0,
				  -1.0,  1.0,  1.0,
				  -1.0,  1.0, -1.0,
				];
				//gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				//cubeVertexBuffer.itemSize = 3;
				//cubeVertexBuffer.numItems = 24;
				
				return result;
			}
	
			function initCubeIndex()
			{
				cubeVertexIndexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
				var cubeVertexIndices = [
					0, 1, 2,      0, 2, 3,    // Front face
					4, 5, 6,      4, 6, 7,    // Back face
					8, 9, 10,     8, 10, 11,  // Top face
					12, 13, 14,   12, 14, 15, // Bottom face
					16, 17, 18,   16, 18, 19, // Right face
					20, 21, 22,   20, 22, 23  // Left face
				];
				gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
				cubeVertexIndexBuffer.itemSize = 1;
				cubeVertexIndexBuffer.numItems = 36;
				
				//return result;
			}
			
			// 684, 1024
			
			function initCubeUV2(width, height, dimx, dimy, idxx, idxy)
			{
				var norm_width, norm_height;
				
				if(height > width) 
				{					
					norm_width = 1.0 - ((height - width) * (1.0 / height));
					norm_height = 1.0;
				}
				else
				{
					norm_width = 1.0;
					norm_height = 1.0 - ((width - height) * (1.0 / width));
				}
				
				//console.log(norm_width + ', ' + norm_height);
				
				var xinc = norm_width / dimx;
				var yinc = norm_height / dimy;
				
				//console.log(xinc + ', ' + yinc);
				
				var xmin = idxx * xinc;
				var xmax = (idxx + 1.0) * xinc;
				
				//console.log('b ' + xmin + ', ' + xmax);
				
				var ymin = idxy * yinc;
				var ymax = (idxy + 1.0) * yinc;
				
				var textureCoords = [
				  // Front face
				  xmin, ymin,
				  xmax, ymin,
				  xmax, ymax,
				  xmin, ymax,

				  // Back face
				  xmax, ymin,
				  xmax, ymax,
				  xmin, ymax,
				  xmin, ymin,

				  // Top face
				  xmin, ymax,
				  xmin, ymin,
				  xmax, ymin,
				  xmax, ymax,

				  // Bottom face
				  xmax, ymax,
				  xmin, ymax,
				  xmin, ymin,
				  xmax, ymin,

				  // Right face
				  xmax, ymin,
				  xmax, ymax,
				  xmin, ymax,
				  xmin, ymin,

				  // Left face
				  xmin, ymin,
				  xmax, ymin,
				  xmax, ymax,
				  xmin, ymax,
				];
				
				cubeUVVertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeUVVertexBuffer);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
				cubeUVVertexBuffer.itemSize = 2;
				cubeUVVertexBuffer.numItems = 24;
				
				//return result;
			}
			
			function initCubeUV()
			{
				
				var textureCoords = [
				  // Front face
				  0.0, 0.0,
				  1.0, 0.0,
				  1.0, 1.0,
				  0.0, 1.0,

				  // Back face
				  1.0, 0.0,
				  1.0, 1.0,
				  0.0, 1.0,
				  0.0, 0.0,

				  // Top face
				  0.0, 1.0,
				  0.0, 0.0,
				  1.0, 0.0,
				  1.0, 1.0,

				  // Bottom face
				  1.0, 1.0,
				  0.0, 1.0,
				  0.0, 0.0,
				  1.0, 0.0,

				  // Right face
				  1.0, 0.0,
				  1.0, 1.0,
				  0.0, 1.0,
				  0.0, 0.0,

				  // Left face
				  0.0, 0.0,
				  1.0, 0.0,
				  1.0, 1.0,
				  0.0, 1.0,
				];
				
				cubeUVVertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeUVVertexBuffer);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
				cubeUVVertexBuffer.itemSize = 2;
				cubeUVVertexBuffer.numItems = 24;
				
				//return result;
			}
			
			function initBuffers()
			{				
				triangleVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
								
				var total_points = (width - 1) * (height - 1) * 6;
				
				var vertices = initVertices();
				var normals = initNormals(vertices);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				triangleVertexPositionBuffer.itemSize = 3;
				triangleVertexPositionBuffer.numItems = total_points;
				
				// ****
				
				triangleVertexNormalBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexNormalBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
				triangleVertexNormalBuffer.itemSize = 3;
				triangleVertexNormalBuffer.numItems = total_points;
				
				// ****
				
				triangleVertexColourBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColourBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(initVerticesColour()), gl.STATIC_DRAW);
				triangleVertexColourBuffer.itemSize = 4;
				triangleVertexColourBuffer.numItems = total_points;
				
				// ***
						
			}
			
			function initCubeBuffers()
			{
				var vertices = initCube();
				
				cubeVertexBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				cubeVertexBuffer.itemSize = 3;
				cubeVertexBuffer.numItems = 24;
				
				initCubeIndex();
				initCubeUV();
				
				var normals = initNormals(vertices);
				
				cubeVertexNormalBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				cubeVertexNormalBuffer.itemSize = 3;
				cubeVertexNormalBuffer.numItems = 24;
			}
			
			var cube_dim_x = 3;
			var cube_dim_y = 3;
			var total_cubes = cube_dim_x * cube_dim_y;//9;
			var total_cube_terms = 10;

			// DILDO
			
			var cube_start_xoffset = -2.5;
			var cube_start_yoffset = -2.5;
			
			var UV_width = 684.0;
			var UV_height = 1024.0;

			var cube_xincrement = 2.5;
			var cube_yincrement = 2.5;			
			
			var xrotation_terms = new Array(total_cubes);
			var yrotation_terms = new Array(total_cubes);
			var zrotation_terms = new Array(total_cubes);
			
			var xrotations = new Array(total_cubes);
			var yrotations = new Array(total_cubes);
			var zrotations = new Array(total_cubes);
			
			var xtrotation = new Array(total_cubes);
			var ytrotation = new Array(total_cubes);
			var ztrotation = new Array(total_cubes);
			
			function initRotations()
			{
				var i;
				
				for(i = 0; i < total_cubes; ++i)
				{
					xrotation_terms[i] = new Array(total_cube_terms);
					yrotation_terms[i] = new Array(total_cube_terms);
					zrotation_terms[i] = new Array(total_cube_terms);
										
					xtrotation[i] = new Array(4);
					ytrotation[i] = new Array(4);
					ztrotation[i] = new Array(4);
												
					xrotations[i] = 0.0;
					yrotations[i] = 0.0;
					zrotations[i] = 0.0;
												
					for(z = 0; z < 4; ++z)
					{
						xtrotation[i][z] = 0.0;
						ytrotation[i][z] = 0.0;
						ztrotation[i][z] = 0.0;
					}
					
					var j;
					
					//var bob = '';
					for(j = 0; j < total_cube_terms; ++j)
					{
						xrotation_terms[i][j] = Math.random() * 6.284;
						yrotation_terms[i][j] = Math.random() * 6.284;
						zrotation_terms[i][j] = Math.random() * 6.284;
						
						//bob += '[' + xrotation_terms[i,j] + ',' + yrotation_terms[i,j] + ',' + zrotation_terms[i,j] + ']';
					}
					
					//console.log(bob);
					
					var half = total_cube_terms / 2;
					
					xrotation_terms[i][half] = 0.0;
					yrotation_terms[i][half] = 0.0;
					zrotation_terms[i][half] = 0.0;
					
					xrotation_terms[i][half - 1] = 0.0;
					yrotation_terms[i][half - 1] = 0.0;
					zrotation_terms[i][half - 1] = 0.0;
				}
			}
			
			var termRotationPosition = 0.0;
			var termRotationIncrement = 0.001;
			var termRotationIndex = 0;
			
			function initAllCubeTerms()
			{
				var i;
				for(i = 0; i < total_cubes; ++i)
				{
					var j;
					for(j = 0; j < 4; ++j)
					{
						xtrotation[i][j] = xrotation_terms[i][j];
						ytrotation[i][j] = yrotation_terms[i][j];
						ztrotation[i][j] = zrotation_terms[i][j];
					}
//					xtrotation[i] = initTerms(xrotation_terms[i]);
//					ytrotation[i] = initTerms(yrotation_terms[i]);
//					ztrotation[i] = initTerms(zrotation_terms[i]);										
				}
				
				termRotationIndex = 3;
			}
					
			function getRotationPosition()
			{			
				termRotationPosition += termRotationIncrement;
				if(termRotationPosition > 1.0)
				{
					termRotationPosition = 0.0;
					//termRotationIndex = incTerm(termRotationIndex, xrotation_terms[0,0]);
					termRotationIndex++;
					if(termRotationIndex >= total_cube_terms)
						termRotationIndex = 0;
					
					//console.log(termRotationIndex);
					
					var i;
					for(i = 0; i < total_cubes; ++i)
					{
						xtrotation[i][0] = xtrotation[i][1];
						xtrotation[i][1] = xtrotation[i][2];
						xtrotation[i][2] = xtrotation[i][3];											
						xtrotation[i][3] = xrotation_terms[i][termRotationIndex];
						
						ytrotation[i][0] = ytrotation[i][1];
						ytrotation[i][1] = ytrotation[i][2];
						ytrotation[i][2] = ytrotation[i][3];											
						ytrotation[i][3] = yrotation_terms[i][termRotationIndex];
						
						ztrotation[i][0] = ztrotation[i][1];
						ztrotation[i][1] = ztrotation[i][2];
						ztrotation[i][2] = ztrotation[i][3];											
						ztrotation[i][3] = zrotation_terms[i][termRotationIndex];
					}
				}
				
				var j;
				
				for(j = 0; j < total_cubes; ++j)
				{
					//var moo = '[' + xtrotation[j,0] + ',' + xtrotation[j,1] + ',' + xtrotation[j,2] + ',' + xtrotation[j,3] + ',' + ']';
					//console.log(moo);
					
					var x = catmull(xtrotation[j][0], xtrotation[j][1], xtrotation[j][2], xtrotation[j][3], termRotationPosition);
					var y = catmull(ytrotation[j][0], ytrotation[j][1], ytrotation[j][2], ytrotation[j][3], termRotationPosition);
					var z = catmull(ztrotation[j][0], ztrotation[j][1], ztrotation[j][2], ztrotation[j][3], termRotationPosition);					
					
					//var bob = ' ' + j + '[' + x + ',' + y + ',' + z + ']';
					//console.log(bob);
					
					xrotations[j] = x;
					yrotations[j] = y;
					zrotations[j] = z;					
				}
			}
			
			var texture;
			
			function handleLoadedTexture(t)
			{
				gl.bindTexture(gl.TEXTURE_2D, t);
				gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
				//gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, t.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
				gl.bindTexture(gl.TEXTURE_2D, null);
			}
						
			var mvMatrix = mat4.create();
			//var mvMatrixStack = [];
			var pMatrix = mat4.create();
			
			/*
			function mvPushMatrix()
			{
				var copy = mat4.create();
				mat4.set(mvMatrix, copy);
				mvMatrixStack.push(copy);
			}
		
			function mvPopMatrix()
			{
				if(mvMatrixStack.length == 0)
				{
					throw "bugger";
				}
				
				mvMatrix = mvMatrixStack.pop();
			}
			*/
			function degToRad(degrees)
			{
				return degrees * Math.PI / 180.0;
			}
						
			var xTranslatePosition = 0.0;
			var yTranslatePosition = 0.0;
			var zTranslatePosition = 0.0;

			var xCubeTranslatePosition = 0.0;
			var yCubeTranslatePosition = 0.0;
			var zCubeTranslatePosition = 0.0;
			
			var xPosition = 0.0;
			var yPosition = 0.0;
			var zPosition = 0.0;
			
			var xLookingAt = 0.0;
			var yLookingAt = 0.0;
			var zLookingAt = 0.0;
			
			function outputMatrix(rotation)
			{
				console.log('[' + rotation[0] + ',' + rotation[1] + ',' + rotation[2] + ',' + rotation[3] + ']');
				console.log('[' + rotation[4] + ',' + rotation[5] + ',' + rotation[6] + ',' + rotation[7] + ']');
				console.log('[' + rotation[8] + ',' + rotation[9] + ',' + rotation[10] + ',' + rotation[11] + ']');
				console.log('[' + rotation[12] + ',' + rotation[13] + ',' + rotation[14] + ',' + rotation[15] + ']');
			}
			
			function switchPrograms(currentProgram, newProgram)
			{
				// Gets the number of attributes in the current and new programs
				var currentAttributes = gl.getProgramParameter(currentProgram, gl.ACTIVE_ATTRIBUTES);
				var newAttributes = gl.getProgramParameter(newProgram, gl.ACTIVE_ATTRIBUTES);

				// Fortunately, in OpenGL, attribute index values are always assigned in the
				// range [0, ..., NUMBER_OF_VERTEX_ATTRIBUTES - 1], so we can use that to
				// enable or disable attributes
				if (newAttributes > currentAttributes) // We need to enable the missing attributes
				{
					for (var i = currentAttributes; i < newAttributes; i++)
					{
						gl.enableVertexAttribArray(i);
					}
				}
				else if (newAttributes < currentAttributes) // We need to disable the extra attributes
				{
					for (var i = newAttributes; i < currentAttributes; i++)
					{
						gl.disableVertexAttribArray(i);
					}
				}

				// With all the attributes now enabled/disabled as they need to be, let's switch!
				gl.useProgram(newProgram);
			}
			
			function drawScene()
			{
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

				mat4.identity(mvMatrix);
				
				mat4.translate(mvMatrix, [0.0, 0.0, -7.0]);			
				mat4.rotate(mvMatrix, degToRad(-90), [1, 0, 0]);
			
				//gl.useProgram(shaderProgram);
				switchPrograms(shaderCubeProgram, shaderProgram);
				
				//mvPushMatrix();

				var rotation = computeRotationMatrix(xLookingAt, yLookingAt, zLookingAt,
												     0.0, -1.0, 0.0,
												     xPosition, yPosition, zPosition);
				mat4.inverse(rotation);									 
				mat4.multiply(mvMatrix, rotation);
				mat4.translate(mvMatrix, [xTranslatePosition, yTranslatePosition, zTranslatePosition]);
					
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexNormalBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, triangleVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColourBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexColourAttribute, triangleVertexColourBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				// ***
				var red = 1.0;
				var green = 1.0;
				var blue = 1.0;
				
				gl.uniform3f(shaderProgram.ambientColourUniform, red, green, blue);
				
				var dirX = 1.0;
				var dirY = 1.0;
				var dirZ = 1.0;
				
				var lightingDirection = [dirX, dirY, dirZ];
				
				var adjustedLD = vec3.create();
				vec3.normalize(lightingDirection, adjustedLD);
				vec3.scale(adjustedLD, -1);
				gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
				
				gl.uniform3f(shaderProgram.directionalColourUniform, red, green, blue);
				
				// ***
				
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
				
				//mvPopMatrix();
			}
			
			function drawCubeScene()
			{
				// add normals to cubes
				// paths to cubes
				// landscape path  + generated path
				// appear from behind camera, go a little faster
				// need perlin noise, some wobble, rotation
				
				//var width = 3, height = 3;
				var i;
				
				var cube_xoffset = cube_start_xoffset;
				var	cube_yoffset = cube_start_yoffset;
									
				mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pCubeMatrix);

				for(x = 0; x < cube_dim_x; ++x)
				{					
					for(y = 0; y < cube_dim_y; ++y)
					{
						var cube = (y * cube_dim_x) + x;
						
						initCubeUV2(UV_width, UV_height, cube_dim_x, cube_dim_y, x, y);
						
						mat4.identity(mvCubeMatrix);
						
						mat4.rotate(mvCubeMatrix, degToRad(-90), [1, 0, 0]);
						//mat4.translate(mvCubeMatrix, [xoffset, 12.0, yoffset]);//-12.0]);	
						mat4.translate(mvCubeMatrix, [cube_xoffset, 0.0, cube_yoffset]);//-12.0]);	
						//console.log(yTranslatePosition);
						mat4.translate(mvCubeMatrix, [xCubeTranslatePosition - absoluteXPosition, yCubeTranslatePosition /*- absoluteYPosition*/, zCubeTranslatePosition - absoluteZPosition]);//-12.0]);	
						
						var rotation = computeRotationMatrix(xLookingAt, yLookingAt, zLookingAt,
												     0.0, -1.0, 0.0,
												     xPosition, yPosition, zPosition);
				mat4.inverse(rotation);									 
				mat4.multiply(mvCubeMatrix, rotation);
				
						// SCALE DOWN HERE
						//mat4.translate(mvCubeMatrix, [xoffset, yoffset + 5.0, -3.0]);//-12.0]);	
						//mat4.translate(mvCubeMatrix, [xoffset - 1.0, 1.0, yoffset - 1.0]);//-12.0]);	
						
						// keep these
						//mat4.rotate(mvCubeMatrix, xrotations[cube], [1,0,0]);
						//mat4.rotate(mvCubeMatrix, yrotations[cube], [0,1,0]);
						//mat4.rotate(mvCubeMatrix, zrotations[cube], [0,0,1]);

						switchPrograms(shaderProgram, shaderCubeProgram);
						
						gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexBuffer);
						gl.vertexAttribPointer(shaderCubeProgram.vertexPositionAttribute, cubeVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

						gl.bindBuffer(gl.ARRAY_BUFFER, cubeUVVertexBuffer);
						gl.vertexAttribPointer(shaderCubeProgram.textureCoordAttribute, cubeUVVertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

						gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
						gl.vertexAttribPointer(shaderCubeProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
						gl.activeTexture(gl.TEXTURE0);
						gl.bindTexture(gl.TEXTURE_2D, texture);
						gl.uniform1i(shaderCubeProgram.samplerUniform, 0);
						
						// ***
						var red = 1.0;
						var green = 1.0;
						var blue = 1.0;
						
						gl.uniform3f(shaderCubeProgram.ambientColourUniform, red, green, blue);
						
						var dirX = 1.0;
						var dirY = 1.0;
						var dirZ = 1.0;
						
						var lightingDirection = [dirX, dirY, dirZ];
						
						var adjustedLD = vec3.create();
						vec3.normalize(lightingDirection, adjustedLD);
						vec3.scale(adjustedLD, -1);
						gl.uniform3fv(shaderCubeProgram.lightingDirectionUniform, adjustedLD);
						
						gl.uniform3f(shaderCubeProgram.directionalColourUniform, red, green, blue);
				
						// ***
						
						gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
						setMatrixCubeUniforms();
						gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
						
						cube_yoffset += cube_yincrement;
					}
					
					cube_yoffset = cube_start_yoffset;
					cube_xoffset += cube_xincrement;
				}
			}
			
			var lastTime = 0;
			
			var lastX = 0.0;
			var lastY = 0.0;
			var lastZ = 0.0;
			
			var lastCubeX = 0.0;
			var lastCubeY = 0.0;
			var lastCubeZ = 0.0;
			
			var absoluteXPosition = 0.0;
			var absoluteYPosition = 0.0;
			var absoluteZPosition = 0.0;
			
			function animate()
			{
				var timeNow = new Date().getTime();
				if(lastTime != 0)
				{
					getRotationPosition();
					var t = getPosition();
				
					var diffX = lastX - t[0];
					var diffY = lastY - t[1];
					var diffZ = lastZ - t[2];
		
					lastX = t[0];
					lastY = t[1];
					lastZ = t[2];
					
					xTranslatePosition += diffX;
					yTranslatePosition += diffY;
					zTranslatePosition += diffZ;
					
					absoluteXPosition += diffX;
					absoluteYPosition += diffY;
					absoluteZPosition += diffZ;
					
					xPosition = t[0];
					yPosition = t[1];
					zPosition = t[2];
					
					xLookingAt = t[3];
					yLookingAt = t[4];
					zLookingAt = t[5];

					// ***
					t = getCubePosition();
					
					diffX = lastCubeX - t[0];
					diffY = lastCubeY - t[1];
					diffZ = lastCubeZ - t[2];
					
					lastCubeX = t[0];
					lastCubeY = t[1];
					lastCubeZ = t[2];
					
					xCubeTranslatePosition += diffX;
					yCubeTranslatePosition += diffY;
					zCubeTranslatePosition += diffZ;
					// ****
					
					var y_increment = (2.0 / height) * y_scale;
					var x_increment = (2.0 / width) * x_scale;
					
					if(xTranslatePosition >= x_increment)
					{									
						while(xTranslatePosition >= x_increment)
						{
							position_x += 1;

							ror();
							seed(hash(position_x + width, position_y));
							init_vertical(0);
						
							xTranslatePosition -= x_increment;
						}
						
						initBuffers();
					}
					else if(xTranslatePosition <= -x_increment)
					{
						while(xTranslatePosition <= -x_increment)
						{
							position_x -= 1;

							rol();
							seed(hash(position_x, position_y));
							init_vertical(width - 1);
							
							xTranslatePosition += x_increment;
						}
						
						initBuffers();
					}
					
					if(yTranslatePosition >= y_increment)
					{
						while(yTranslatePosition >= y_increment)
						{
							position_y += 1;

							rod();
							seed(hash(position_x, position_y + height));
							init_horz(0);	
							
							yTranslatePosition -= y_increment;
						}
						
						initBuffers();
					}
					else if(yTranslatePosition <= -y_increment)
					{					
						while(yTranslatePosition <= -y_increment)
						{
							position_y -= 1;

							rou();
							seed(hash(position_x, position_y));
							init_horz(height - 1);
										
							yTranslatePosition += y_increment;
						}
						
						initBuffers();
					}
				}
				
				lastTime = timeNow;
			}
			
			function tick()
			{
				requestAnimationFrame(tick);
				animate();							
				drawScene();
				//drawCubeScene();
			}
			
			var totalTextures = 1;
			var loadedTextures = 0;
			
			function initTextures()
			{
				texture = gl.createTexture();
				texture.image = new Image();
				//texture.image.crossOrigin = "anonymous";
				texture.image.onload = function() 
				{ 
					handleLoadedTexture(texture);
					++loadedTextures;
					if(loadedTextures >= totalTextures)
					{
						//alert('start');
						tick();
					}
				}
				
				// IMAGE SHOULD BE A POWER OF TWO
				texture.image.src = "images/image2square.jpg";
				//texture.image.src = "images/nehe.gif";
			}
			
			function webGlStart()
			{	
				start();
			
				var canvas = document.getElementById("mycanvas");
				initGL(canvas);
				initShaders();	
				initCubeShader();
				initBuffers();
				initCubeBuffers();
				initAllTerms();				
				initRotations();
				initAllCubeTerms();
				//initTextures();
								
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
				
				//drawScene();
				//drawCubeScene();
				
				tick();				
			}
			
			//document.onkeydown = keyDown;
			//document.onkeyup = keyUp;
			
		</script>
			
	</head>

	<body onload="webGlStart();">
		<canvas id="mycanvas" style="border:none;" width="500" height="500">
		</canvas>
	</body>

</html>