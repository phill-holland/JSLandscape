<!DOCTYPE html>
<html>
	<head>
		<script type="text/javascript" src="scripts/glMatrix-0.9.5.min.js"></script>
		<script type="text/javascript" src="scripts/general.js"></script>
				
		<script id="shader-fs" type="x-shader/x-fragment">
			precision mediump float;

			varying vec4 vColour;
			
			varying vec3 vLightWeighting;
			
			void main(void) 
			{
				gl_FragColor = vec4(vColour.rgb * vLightWeighting, vColour.a);
			}
		</script>

		<script id="shader-vs" type="x-shader/x-vertex">
			attribute vec3 aVertexPosition;
			attribute vec3 aVertexNormal;
			attribute vec4 aVertexColour;
			
			uniform mat4 uMVMatrix;
			uniform mat4 uPMatrix;
			uniform mat3 uNMatrix;

			varying vec4 vColour;
			
			uniform vec3 uAmbientColour;
			uniform vec3 uLightingDirection;
			uniform vec3 uDirectionalColour;
			
			varying vec3 vLightWeighting;
			
			void main(void) 
			{
				gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
				vColour = aVertexColour;
				
				vec3 transformedNormal = uNMatrix * aVertexNormal;
				float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
				vLightWeighting = uAmbientColour + uDirectionalColour * directionalLightWeighting;
			}
			
		</script>
	
		<script type="text/javascript">
		
			var width = 12;
			var height = 12;
			
			var height_map = new Array(width * height);
			
			var temp_x = new Array(width * height);
			var temp_y = new Array(width * height);
			
			var position_x = 0;
			var position_y = 0;
			
			function start()
			{
				for(var i = 0; i < width * height; ++i)
				{
					height_map[i] = 0;
				}
				
				position_x = 0;
				seed(position_x);
				
				for(var x = 0; x < width; ++x)
				{
					seed(x);
					init_vertical(x);
				}
			}
						
			
			function init_vertical(x_offset)
			{
				var y;
				var x = x_offset;
				
				for(y = 0; y < height; ++y)
				{
					height_map[x] = random();
					x += width;
				}
			}
		
			function init_horz(y_offset)
			{
				var y = y_offset * width;
				var x;
				
				for(x = 0; x < width; ++x)
				{
					height_map[y + x] = random();
				}
			}
			
			function ror()
			{
				var yoffset = 0;
				for(var y = 0; y < height; ++y)
				{
					for(var x = width - 1; x >= 0; x--)
					{
						var destination = yoffset + x;
						var source = destination - 1;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rol()
			{
				var yoffset = 0;
				for(var y = 0; y < height; ++y)
				{
					for(var x = 0; x < width - 1; ++x)
					{
						var destination = yoffset + x;
						var source = destination + 1;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rou()
			{
				var yoffset = 0;
				for(var y = 0; y < height - 1; ++y)
				{
					for(var x = 0; x < width; ++x)
					{
						var destination = yoffset + x;
						var source = yoffset + width + x;
						height_map[destination] = height_map[source];
					}
					yoffset += width;
				}
			}
			
			function rod()
			{
				var yoffset = (height - 1) * width;
				for(var y = height - 1; y >= 0; --y)
				{
					for(var x = 0; x < width; ++x)
					{
						var destination = yoffset + x;
						var source = (yoffset - width) + x;
						height_map[destination] = height_map[source];
					}
					yoffset -= width;
				}
			}

			function hash(a, b)
			{
				return (a << 1) ^ b;
			}
					
		</script>
		
		<script type="text/javascript">
		
			var x_terms = [  0.0, 20.0, 40.0, 40.0, 40.0 ];
			var y_terms = [  0.0,  0.0,  0.0, 20.0, 40.0 ];
			var z_terms = [  2.0,  2.0,  2.0,  2.0,  2.0 ];
			
			var looking_x_terms = [ 20.0, 40.0, 40.0, 40.0 ];
			var looking_y_terms = [  0.0,  0.0, 20.0, 40.0 ];
			var looking_z_terms = [  0.0,  0.0,  0.0,  0.0 ];
			
			var termIndex = 0;
			var termPosition = 0.0;
			var termIncrement = 0.005;

			var xt = [ 0.0, 0.0, 0.0, 0.0 ];
			var yt = [ 0.0, 0.0, 0.0, 0.0 ];
			var zt = [ 0.0, 0.0, 0.0, 0.0 ];
			
			var lookingxt = [ 0.0, 0.0, 0.0, 0.0 ];
			var lookingyt = [ 0.0, 0.0, 0.0, 0.0 ];
			var lookingzt = [ 0.0, 0.0, 0.0, 0.0 ];
			
			var lastX_walk = 0.0;
			var lastY_walk = 0.0;

			var lastX_walk_increment = 40.0;
			var lastY_walk_increment = 40.0;
			
			function generatePaths()
			{
				var terms = 8;
				var i;
				
				for(i = 0; i < terms; ++i)
				{
					var x = Math.random() * lastX_walk_increment;
					var y = Math.random() * lastY_walk_increment;
					
					x_terms[i] = lastX_walk + x;
					y_terms[i] = lastY_walk + y;
					
					lastX_walk += x;
					lastY_walk += y;
				}
				
				for(i = 0; i < terms - 1; ++i)
				{
					looking_x_terms[i] = x_terms[i + 1];
					looking_y_terms[i] = y_terms[i + 1];
					
					cube_x_terms[i] = x_terms[i + 1];
				}
			}
			
			function getNextPath()
			{
				var terms = 8;
				var i;
				
				for(i = 0; i < terms - 1; ++i)
				{
					x_terms[i] = x_terms[i + 1];
					y_terms[i] = y_terms[i + 1];
					
					looking_x_terms[i] = x_terms[i + 1];
					looking_y_terms[i] = y_terms[i + 1];
					
					cube_x_terms[i] = x_terms[i + 1];
				}

				var x = Math.random() * lastX_walk_increment;
				var y = Math.random() * lastY_walk_increment;
				
				var tx = lastX_walk + x;
				var ty = lastY_walk + y;
				
				x_terms[terms - 1] = tx;
				y_terms[terms - 1] = ty;
				
				looking_x_terms[terms - 1] = tx;
				looking_y_terms[terms - 1] = ty;
				
				cube_x_terms = tx;
				
				lastX_walk += x;
				lastY_walk += y;
			}
			
			function incTerm(index, data)
			{
				var i = index + 1;
				if(i >= data.length) i = 0;
				
				return i;
			}
							
			function initTerms(data)
			{			
				var result = [ data[0], data[1], data[2], data[3] ];
				
				return result;
			}
			
			function shuffleTerms(data)
			{
				var result = [ data[1], data[2], data[3], 0.0 ];
				
				return result;
			}
			
			function getPosition()
			{			
				termPosition += termIncrement;
				if(termPosition > 1.0)
				{
					var next_x = x_terms[4];
					var next_y = y_terms[4];
					var next_z = z_terms[4];
					
					next_x += (Math.random() * 40.0) - 20.0;
					next_y += 20.0;
					next_z = 2.0;
					
					x_terms = [ x_terms[1], x_terms[2], x_terms[3], x_terms[4], next_x ];//shuffleTerms(x_terms); // check this 
					y_terms = [ y_terms[1], y_terms[2], y_terms[3], y_terms[4], next_y ];
					z_terms = [ z_terms[1], z_terms[2], z_terms[3], z_terms[4], next_z ];
					
					looking_x_terms = [ looking_x_terms[1], looking_x_terms[2], looking_x_terms[3], next_x ];//shuffleTerms(looking_x_terms);
					looking_y_terms = [ looking_y_terms[1], looking_y_terms[2], looking_y_terms[3], next_y ];
					looking_z_terms = [ looking_z_terms[1], looking_z_terms[2], looking_z_terms[3], next_z ];
					
					termPosition = 0.0;
					termIndex = incTerm(termIndex, x_terms);
				}
				
				var x = catmull(x_terms[0], x_terms[1], x_terms[2], x_terms[3], termPosition);
				var y = catmull(y_terms[0], y_terms[1], y_terms[2], y_terms[3], termPosition);
				var z = catmull(z_terms[0], z_terms[1], z_terms[2], z_terms[3], termPosition);
				
				var lx = catmull(looking_x_terms[0], looking_x_terms[1], looking_x_terms[2], looking_z_terms[3], termPosition);
				var ly = catmull(looking_y_terms[0], looking_y_terms[1], looking_y_terms[2], looking_z_terms[3], termPosition);
				var lz = catmull(looking_z_terms[0], looking_z_terms[1], looking_z_terms[2], looking_z_terms[3], termPosition);
	
				var result = [ x, y, z, lx, ly, lz ];
				
				return result;
			}		
		</script>
		
		<script type="text/javascript">

			var gl;
			
			function initGL(canvas) 
			{
				try 
				{
					gl = canvas.getContext("experimental-webgl");
					gl.viewportWidth = canvas.width;
					gl.viewportHeight = canvas.height;
				} 
				catch (e)
				{
				}

				if (!gl) alert("Could not initialise WebGL, sorry :-(");
			}

			function getShader(gl, id) 
			{
				var shaderScript = document.getElementById(id);
				if (!shaderScript) return null;

				var str = "";
				var k = shaderScript.firstChild;
				while (k) 
				{
					if (k.nodeType == 3) 
					{
						str += k.textContent;
					}
					k = k.nextSibling;
				}

				var shader;
				if (shaderScript.type == "x-shader/x-fragment") 
				{
					shader = gl.createShader(gl.FRAGMENT_SHADER);
				} 
				else if (shaderScript.type == "x-shader/x-vertex") 
				{
					shader = gl.createShader(gl.VERTEX_SHADER);
				} 
				else return null;

				gl.shaderSource(shader, str);
				gl.compileShader(shader);

				if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) 
				{
					alert(gl.getShaderInfoLog(shader));
					return null;
				}

				return shader;
			}

			var shaderProgram;
			var shaderCubeProgram;
			
			function initShaders()
			{
				var fragmentShader = getShader(gl, "shader-fs");
				var vertexShader = getShader(gl, "shader-vs");

				shaderProgram = gl.createProgram();
				gl.attachShader(shaderProgram, vertexShader);
				gl.attachShader(shaderProgram, fragmentShader);
				gl.linkProgram(shaderProgram);

				if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) 
				{
					alert("Could not initialise shaders");
				}

				gl.useProgram(shaderProgram);

				shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
				gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);

				shaderProgram.vertexNormalAttribute = gl.getAttribLocation(shaderProgram, "aVertexNormal");
				gl.enableVertexAttribArray(shaderProgram.vertexNormalAttribute);
				
				shaderProgram.vertexColourAttribute = gl.getAttribLocation(shaderProgram, "aVertexColour");
				gl.enableVertexAttribArray(shaderProgram.vertexColourAttribute);

				shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
				shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");				
				shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");
			
				shaderProgram.ambientColourUniform = gl.getUniformLocation(shaderProgram, "uAmbientColour");
				shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
				shaderProgram.directionalColourUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColour");
			}
			
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();

			function setMatrixUniforms() 
			{
				gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
				gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
				
				var normalMatrix = mat3.create();
				mat4.toInverseMat3(mvMatrix, normalMatrix);
				mat3.transpose(normalMatrix);
				gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
			}
			
			var triangleVertexPositionBuffer;
			var triangleVertexNormalBuffer;
			var triangleVertexColourBuffer;

			var x_scale = 5.0;
			var y_scale = 5.0;
			var z_scale = 1.0;
				
			function initVertices()
			{
				var total_points = (width - 1) * (height - 1) * 6;
			
				var vertices = new Array(total_points * 3);				
				
				var y_value = -1.0;
				
				var y_increment = 2.0 / height;
				var x_increment = 2.0 / width;
								
				var index = 0;
				
				for(y = 0; y < height - 1; ++y)
				{
					var x_value = -1.0;
					
					for(x = 0; x < width - 1; ++x)
					{
						var top_left = (y * width) + x;
						var bottom_left = ((y + 1) * width) + x;
						
						var top_right = top_left + 1;
						var bottom_right = bottom_left + 1;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_left] * z_scale;

						
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_right] * z_scale;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_left] * z_scale;
												
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = y_value * y_scale;
						vertices[index++] = height_map[top_right] * z_scale;
						
						vertices[index++] = (x_value + x_increment) * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_right] * z_scale;
						
						vertices[index++] = x_value * x_scale;
						vertices[index++] = (y_value + y_increment) * y_scale;
						vertices[index++] = height_map[bottom_left] * z_scale;
						
						x_value += x_increment;
					}
					
					y_value += y_increment;
				}
				
				return vertices;
			}
			
			function initNormals(vertices)
			{
				var total_points = (width - 1) * (height - 1) * 6;
			
				var normals = new Array(total_points * 3);				
												
				var index;
				var output = 0;
				
				for(index = 0; index < vertices.length; index += 9)
				{
					var x1 = vertices[index];
					var y1 = vertices[index + 1];
					var z1 = vertices[index + 2];
					
					var x2 = vertices[index + 3];
					var y2 = vertices[index + 4];
					var z2 = vertices[index + 5];
					
					var x3 = vertices[index + 6];
					var y3 = vertices[index + 7];
					var z3 = vertices[index + 8];
					
					var v1x = x1 - x2;
					var v1y = y1 - y2;
					var v1z = z1 - z2;
					
					var v2x = x2 - x3;
					var v2y = y2 - y3;
					var v2z = z2 - z3;
					
					var x = v2y * v1z - v2z * v1y;
					var y = v2z * v1x - v2x * v1z;
					var z = v2x * v1y - v2y * v1x;
					
					var length = 1.0 / (Math.sqrt(x * x + y * y + z * z) + 0.001);
					
					var temp_x = x * length;
					var temp_y = y * length;
					var temp_z = z * length;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
					normals[output++] = temp_x;
					normals[output++] = temp_y;
					normals[output++] = temp_z;
					
				}
				
				return normals;
			}
			
			function initVerticesColour()
			{
				var total_points = (width - 1) * (height - 1) * 6;
				
				var colours = new Array(total_points * 4); // varies depending on height
				
				var global_width = 100.0;
				var global_height = 100.0;
				 
				var g = ((position_x / (global_width + width)) / 2.0) + 0.5;
				var f = ((position_y / (global_height + height)) / 2.0) + 0.5;
				
				var colour_increment = (1.0 / global_height) / 2.0;
				var colour_increment_x = (1.0 / global_width) / 2.0;
				
				var red = 0.0;
				var green = 0.0;
				var blue = 1.0;
				var alpha = 1.0;
				
				var colour_index = 0;
				
				for(y = 0; y < height - 1; ++y)
				{			
					for(x = 0; x < width - 1; ++x)
					{					
						// top left
						colours[colour_index++] = f + (y * colour_increment);//red;
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// top right
						colours[colour_index++] = f + (y * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom left
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// ***
						
						// top right
						colours[colour_index++] = f + (y * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom right
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + ((x + 1.0) * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;
						
						// bottom left
						colours[colour_index++] = f + ((y + 1.0) * colour_increment);
						colours[colour_index++] = g + (x * colour_increment_x);
						colours[colour_index++] = blue;
						colours[colour_index++] = alpha;						
					}
				}
				
				return colours;
			}
			
			function initBuffers()
			{				
				triangleVertexPositionBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
								
				var total_points = (width - 1) * (height - 1) * 6;
				
				var vertices = initVertices();
				var normals = initNormals(vertices);
				
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
				triangleVertexPositionBuffer.itemSize = 3;
				triangleVertexPositionBuffer.numItems = total_points;
				
				// ****
				
				triangleVertexNormalBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexNormalBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
				triangleVertexNormalBuffer.itemSize = 3;
				triangleVertexNormalBuffer.numItems = total_points;
				
				// ****
				
				triangleVertexColourBuffer = gl.createBuffer();
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColourBuffer);
				gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(initVerticesColour()), gl.STATIC_DRAW);
				triangleVertexColourBuffer.itemSize = 4;
				triangleVertexColourBuffer.numItems = total_points;
				
				// ***
						
			}
			
			var termRotationPosition = 0.0;
			var termRotationIncrement = 0.001;
			var termRotationIndex = 0;
						
			function getRotationPosition()
			{			
				termRotationPosition += termRotationIncrement;
				if(termRotationPosition > 1.0)
				{
					termRotationPosition = 0.0;
					termRotationIndex++;
					if(termRotationIndex >= total_cube_terms)
						termRotationIndex = 0;
					
					var i;
					for(i = 0; i < total_cubes; ++i)
					{
						xtrotation[i][0] = xtrotation[i][1];
						xtrotation[i][1] = xtrotation[i][2];
						xtrotation[i][2] = xtrotation[i][3];											
						xtrotation[i][3] = xrotation_terms[i][termRotationIndex];
						
						ytrotation[i][0] = ytrotation[i][1];
						ytrotation[i][1] = ytrotation[i][2];
						ytrotation[i][2] = ytrotation[i][3];											
						ytrotation[i][3] = yrotation_terms[i][termRotationIndex];
						
						ztrotation[i][0] = ztrotation[i][1];
						ztrotation[i][1] = ztrotation[i][2];
						ztrotation[i][2] = ztrotation[i][3];											
						ztrotation[i][3] = zrotation_terms[i][termRotationIndex];
					}
				}				
			}
				
			var mvMatrix = mat4.create();
			var pMatrix = mat4.create();
					
			var xTranslatePosition = 0.0;
			var yTranslatePosition = 0.0;
			var zTranslatePosition = 0.0;

			var xCubeTranslatePosition = 0.0;
			var yCubeTranslatePosition = 0.0;
			var zCubeTranslatePosition = 0.0;
			
			var xPosition = 0.0;
			var yPosition = 0.0;
			var zPosition = 0.0;
			
			var xLookingAt = 0.0;
			var yLookingAt = 0.0;
			var zLookingAt = 0.0;			

			function drawScene()
			{
				gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
				gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

				mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);

				mat4.identity(mvMatrix);
				
				mat4.translate(mvMatrix, [0.0, 0.0, -7.0]);			
				mat4.rotate(mvMatrix, degToRad(-90), [1, 0, 0]);
		
				var rotation = computeRotationMatrix(xLookingAt, yLookingAt, zLookingAt,
												     0.0, -1.0, 0.0,
												     xPosition, yPosition, zPosition);
				mat4.inverse(rotation);									 
				mat4.multiply(mvMatrix, rotation);
				mat4.translate(mvMatrix, [xTranslatePosition, yTranslatePosition, zTranslatePosition]);
					
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexNormalBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, triangleVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
				gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColourBuffer);
				gl.vertexAttribPointer(shaderProgram.vertexColourAttribute, triangleVertexColourBuffer.itemSize, gl.FLOAT, false, 0, 0);
				
				// ***
				var red = 1.0;
				var green = 1.0;
				var blue = 1.0;
				
				gl.uniform3f(shaderProgram.ambientColourUniform, red, green, blue);
				
				var dirX = 1.0;
				var dirY = 1.0;
				var dirZ = 1.0;
				
				var lightingDirection = [dirX, dirY, dirZ];
				
				var adjustedLD = vec3.create();
				vec3.normalize(lightingDirection, adjustedLD);
				vec3.scale(adjustedLD, -1);
				gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
				
				gl.uniform3f(shaderProgram.directionalColourUniform, red, green, blue);
				
				// ***
				
				setMatrixUniforms();
				gl.drawArrays(gl.TRIANGLES, 0, triangleVertexPositionBuffer.numItems);
			}
			
			var lastTime = 0;
			
			var lastX = 0.0;
			var lastY = 0.0;
			var lastZ = 0.0;
			
			var absoluteXPosition = 0.0;
			var absoluteYPosition = 0.0;
			var absoluteZPosition = 0.0;
			
			function animate()
			{
				var timeNow = new Date().getTime();
				if(lastTime != 0)
				{
					getRotationPosition();
					var t = getPosition();
				
					var diffX = lastX - t[0];
					var diffY = lastY - t[1];
					var diffZ = lastZ - t[2];
		
					lastX = t[0];
					lastY = t[1];
					lastZ = t[2];
					
					xTranslatePosition += diffX;
					yTranslatePosition += diffY;
					zTranslatePosition += diffZ;
					
					absoluteXPosition += diffX;
					absoluteYPosition += diffY;
					absoluteZPosition += diffZ;
					
					xPosition = t[0];
					yPosition = t[1];
					zPosition = t[2];
					
					xLookingAt = t[3];
					yLookingAt = t[4];
					zLookingAt = t[5];
										
					var y_increment = (2.0 / height) * y_scale;
					var x_increment = (2.0 / width) * x_scale;
					
					if(xTranslatePosition >= x_increment)
					{									
						while(xTranslatePosition >= x_increment)
						{
							position_x += 1;

							ror();
							seed(hash(position_x + width, position_y));
							init_vertical(0);
						
							xTranslatePosition -= x_increment;
						}
						
						initBuffers();
					}
					else if(xTranslatePosition <= -x_increment)
					{
						while(xTranslatePosition <= -x_increment)
						{
							position_x -= 1;

							rol();
							seed(hash(position_x, position_y));
							init_vertical(width - 1);
							
							xTranslatePosition += x_increment;
						}
						
						initBuffers();
					}
					
					if(yTranslatePosition >= y_increment)
					{
						while(yTranslatePosition >= y_increment)
						{
							position_y += 1;

							rod();
							seed(hash(position_x, position_y + height));
							init_horz(0);	
							
							yTranslatePosition -= y_increment;
						}
						
						initBuffers();
					}
					else if(yTranslatePosition <= -y_increment)
					{					
						while(yTranslatePosition <= -y_increment)
						{
							position_y -= 1;

							rou();
							seed(hash(position_x, position_y));
							init_horz(height - 1);
										
							yTranslatePosition += y_increment;
						}
						
						initBuffers();
					}
				}
				
				lastTime = timeNow;
			}
			
			function tick()
			{
				requestAnimationFrame(tick);
				animate();							
				drawScene();
			}
			
			function webGlStart()
			{	
				start();
			
				var canvas = document.getElementById("mycanvas");
				initGL(canvas);
				initShaders();	
				initBuffers();
								
				gl.clearColor(0.0, 0.0, 0.0, 1.0);
				gl.enable(gl.DEPTH_TEST);
								
				tick();				
			}
						
		</script>
			
	</head>

	<body onload="webGlStart();">
		<canvas id="mycanvas" style="border:none;" width="500" height="500">
		</canvas>
	</body>

</html>